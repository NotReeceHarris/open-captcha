
use crate::rendering::shaders::{RenderingShader, ShadowShader};
use crate::rendering::gl::{get_model_view_matrix, get_projection_matrix, get_viewport_matrix};
use crate::rendering::drawing::draw_faces;

use std::sync::Arc;
use obj::{Obj, TexturedVertex};
use image::{ImageBuffer, RgbaImage, Rgba};
use nalgebra::{Point3, Vector3, Matrix2x3, Matrix3};

const WIDTH: u32 = 200;
const HEIGHT: u32 = 200;

/// Represents the camera properties used for rendering
struct Camera {
    pub position: Point3<f32>,
    pub focal_length: f32,
    pub view_point: Point3<f32>,
}

pub fn render(
    model: Arc<Obj<TexturedVertex>>,
    texture: ImageBuffer<Rgba<u8>, Vec<u8>>,
    normal_map: ImageBuffer<Rgba<u8>, Vec<u8>>,
    specular_map: ImageBuffer<Rgba<u8>, Vec<u8>>,
) -> RgbaImage {
    let mut color_buffer = RgbaImage::from_pixel(WIDTH, HEIGHT, Rgba([0, 0, 0, 255]));
    let mut _buffer = RgbaImage::from_pixel(WIDTH, HEIGHT, Rgba([0, 0, 0, 255]));

    use std::time::Instant;
    let now = Instant::now();

    // Frame properties
    let (width, height) = (color_buffer.width() as f32, color_buffer.height() as f32);
    let depth = 1024.;

    // Model configuration
    let model_pos = Point3::new(0., 0., 0.);
    let model_scale = Vector3::new(1., 1., 1.);

    // Camera configuration
    let camera = Camera {
        position: Point3::new(0., 0., 1.),
        focal_length: 3.,
        view_point: model_pos,
    };

    // Light configuration
    let ambient_light = 5.;
    let dir_light = Vector3::new(-1., 0., 1.5);

    // Z buffer
    let mut z_buffer = vec![vec![f32::NEG_INFINITY; height as usize]; width as usize];

    // Shadow buffer
    let mut shadow_buffer = vec![vec![f32::NEG_INFINITY; height as usize]; width as usize];

    // Transformation matrices
    let model_view = get_model_view_matrix(
        camera.position,
        camera.view_point,
        model_pos,
        model_scale,
        Vector3::new(0., 1., 0.),
    );
    let projection = get_projection_matrix(camera.focal_length);
    let model_view_it = model_view.try_inverse().unwrap().transpose();
    let viewport = get_viewport_matrix(height, width, depth);

    let shadow_mat = get_model_view_matrix(
        Point3::<f32>::origin() + dir_light,
        model_pos,
        model_pos,
        model_scale,
        Vector3::new(0., 1., 0.),
    );

    // Shaders
    let mut shadow_shader = ShadowShader {
        model: &model,
        uniform_shadow_mv_mat: shadow_mat,
        uniform_viewport: viewport,

        varying_view_tri: Matrix3::<f32>::zeros(),
    };
    // Compute shadows
    draw_faces(&model, &mut _buffer, &mut shadow_buffer, &mut shadow_shader);

    let mut rendering_shader = RenderingShader {
        model: &model,
        shadow_buffer: &shadow_buffer,
        uniform_model_view: model_view,
        uniform_model_view_it: model_view_it,
        uniform_shadow_mv_mat: shadow_mat,
        uniform_projection: projection,
        uniform_viewport: viewport,
        uniform_ambient_light: ambient_light,
        uniform_dir_light: (model_view * dir_light.insert_row(3, 0.)).xyz().normalize(),
        uniform_texture: texture,
        uniform_normal_map: normal_map,
        uniform_specular_map: specular_map,

        varying_uv: Matrix2x3::<f32>::zeros(),
        varying_normals: Matrix3::<f32>::zeros(),
        varying_view_tri: Matrix3::<f32>::zeros(),
        varying_shadow_tri: Matrix3::<f32>::zeros(),
    };

    // Render model
    draw_faces(
        &model,
        &mut color_buffer,
        &mut z_buffer,
        &mut rendering_shader,
    );

    image::imageops::flip_vertical_in_place(&mut color_buffer);

    color_buffer
}